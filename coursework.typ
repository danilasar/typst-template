#import "@local/ssu-template:0.0.1": (
  conf,
  defabbr,
  intro,
  conclusion,
  definition,
  theorem,
  // source-file,
  code-block,
  zebraw,
  annexes-start,
)
#show: conf.with(
  title: [Сравнение достаточных условий гамильтоновости графов с использованием добровольных вычислений],
  type: "referat",
  info: (
    author: (
      name: [Гущина Андрея Юрьевича],
      faculty: [КНиИТ],
      group: "631",
      sex: "male",
    ),
    inspector: (
      degree: "",
      name: "",
    ),
  ),
  settings: (
    title_page: (
      enabled: true,
    ),
    contents_page: (
      enabled: true,
    ),
  ),
)

#let source-file(file) = {
  raw(read(file), block: true)
}

#defabbr

/ Digital Audio Workstation (DAW): цифровая звуковая рабочая станция
/ Stochastic Gradient Descent (SGD): стохастический градиентный спуск
/ Long-Short Term Memory (LSTM): сети долгой краткосрочной памяти
/ Application Programming Inferface (API): программный интерфейс действия
/ JavaScript Object Notation (JSON): один из форматов данными
/ Амплитудно-частотная характеристика (АЧХ): зависимость амплитуды
  колебаний сигнала от их частоты

#intro

В 1859 году сэр Уильям Роуэн Гамильтон выпустил в продажу игру
"Путешествие вокруг света". От играющего требовалось обойти
"вокруг света", то есть найти такой обход рёбер додекаэдра, чтобы
пройти через каждую вершину ровно один раз.

К созданию этой головоломки его привело изучение додекаэдра, которое в
свою очередь привело к введению в теорию графов такого понятия, как
"гамильтонов граф".

Проверка произвольного графа на гамильтоновость представляет из себя
задачу полного перебора всех возможных построений гамильтонова цикла,
что является NP-полной задачей, крайне неэффективной для вычисления.

В связи с этим было предложено большое количество вариантов более
эффективной проверки на гамильтоновость графов с наложением определённых
условий. Например, одним из первых достаточных условий гамильтоновости
графов было условие, предложенное Дираком в 1952 году. Оно является
крайне эффективным для вычисления, но при этом позволяет определить
менее 1% гамильтоновых графов.

Впоследствии были предложены условия Оре, Поша и Бонди-Хватала,
обобщающие условие Дирака и позволяющие определить большее количество
гамильтоновых графов.

В данной работе рассмотрены теоремы, основанные на понятии
#emph[жёсткости], введённом Вацлавом Хваталом в 1973 году и теоремы,
основанные на широко используемой концепции #emph[запрещённых
  подграфов], а также сравнение данных теорем с указанными выше
достаточными условиями гамильтоновости графов.

#heading("aboba", numbering: none)

= Основные определения <основные-определения>

Рассмотрим основные определения, которые понадобятся при изучении
достаточных условий гамильтоновости графов. Данные определения даются по
работам Bogomolov_1997 и abrosimov2016graphs.

#definition[
  Неориентированным графом (везде далее просто графом) называется пара
  $G = (V \, alpha)$, где $alpha$ --- симметричное и антирефлексивное
  отношение на множестве вершин $V$, называемое отношением смежности. Если
  $(u \, v) in a$, то говорят, что вершины $u$ и $v$ смежны и эти вершины
  соединены ребром $(u \, v)$. При этом $(u \, v)$ и $(v \, u)$ это одно и
  то же ребро, которое обозначают ${ u \, v }$. Говорят, что ребро
  ${ u \, v }$ инцидентно каждой из вершин $u$ и $v$ и эти вершины
  называются концевыми вершинами или концами ребра ${ u \, v }$. Два ребра
  называются смежными, если они имеют общую концевую вершину.
]

#definition[
  Граф называется полным, если любые две его вершины соединены ребром, т.~е.
  если $alpha = (V times V) - Delta$.
]

#definition[
  Путём в графе называется последовательность дуг $(v_0 \, v_1)$,
  $(v_1 \, v_2)$, $dots.h$, $(v_(n - 1) \, v_n)$, в которой
  $(v_(i - 1) \, v_i) in alpha med (forall med 1 lt.eq i lt.eq n)$. Если
  начальная и конечная вершины совпадают, то путь называется циклическим.
  Путь, каждая вершина которого принадлежит не более чем двум его рёбрам,
  считается простым. Если начальная вершина простого пути совпадает с
  конечной, путь называют циклом, в противном случае --- цепью.
]

#definition[
  Цикл или цепь, содержащие все вершины графа, называются гамильтоновыми.
  Граф, содержащий гамильтонов цикл, также называется гамильтоновым.
]

#definition[
  Вершины $u$ и $v$ графа $G$ называются связанными, если в $G$ существует
  проходящий через них путь. Классы эквивалентности отношения связности
  называются компонентами связности (или просто компонентами) графа.
]

#definition[
  Частью графа называется граф $G^(\*) = (V^(\*) \, alpha^(\*))$, где
  $V^(\*) subset.eq V$ и
  $alpha^(\*) subset.eq (V^(\*) times V^(\*)) inter alpha$.
]

#definition[
  Подграф графа $G$ --- это такая его часть
  $G^(\*) = (V^(\*) \, alpha^(\*))$, которая содержит все дуги графа $G$,
  соединяющие попавшие в данную часть вершины, т. е.
  $alpha^(\*) = (V^(\*) times V^(\*)) inter alpha$.
]

#definition[
  Степенью вершины $v$ в неориентированном графе $G$ будем называть
  количество вершин в $G$, смежных с $v$, и обозначать через $d (v)$.
]

= Основные достаточные условия гамильтоновости графов
<основные-достаточные-условия-гамильтоновости-графов>
#theorem([Дирак])[
  Если в графе $G$ с числом вершин $n gt.eq 3$ степень любой
  вершины $d (u) gt.eq n \/ 2$, то граф $G$ --- гамильтонов.
] <thm:dirac>
```
fn dirac_theorem(g: &Graph) -> bool {
    for vertex in 0..g.size {
        if (g.degree(vertex) as f64) < g.size as f64 / 2.0 {
            return false;
        }
    }
    return true;
}
```

Вычислительная сложность данного алгоритма --- $O (n + m)$.

#theorem([Оре])[
  Если в графе $G$ с числом вершин $n gt.eq 3$ для любых двух
  несмежных вершин $u$ и $v$ выполняется неравенство
  $d (u) + d (v) gt.eq n$, то граф $G$ --- гамильтонов.
] <thm:ore>
```
fn ore_theorem(g: &Graph) -> bool {
    for v1 in 0..g.size {
        for v2 in 0..g.size {
            if v1 == v2 || g.matrix[v1][v2] != 0 {
                continue;
            }
            let d1 = g.degree(v1);
            let d2 = g.degree(v2);
            if d1 + d2 < g.size {
                return false;
            }
        }
    }
    return true;
}
```

#theorem([Поша])[
  Если граф $G$ с числом вершин $n gt.eq 3$ и степенной последовательностью
  $d_1 lt.eq dots.h lt.eq d_n$ удовлетворяет следующим двум условиям, то он
  гамильтонов:

  + для всякого $k : med 1 lt.eq k < frac(n - 1, 2)$ число вершин со
    степенями меньшими или равными $k$ меньше, чем $k$;
  + для нечётного $n$ число вершин со степенями меньшими или равными
    $frac(n - 1, 2)$ не превосходит $n - 1 2$.
] <thm:posa>
```
fn posa_theorem(g: &Graph) -> bool {
    let mut degrees = Vec::new();
    for v in 0..g.size {
        degrees.push(g.degree(v));
    }

    let end = if g.size % 2 == 0 {
        g.size / 2
    } else {
        (g.size - 1) / 2
    };

    for k in 1..end {
        let mut cnt = 0;
        for d in &degrees {
            if *d <= k {
                cnt += 1;
            }
        }
        if cnt >= k {
            return false;
        }
    }
    if g.size % 2 != 0 {
        let mut cnt = 0;
        for d in &degrees {
            if *d <= end {
                cnt += 1;
            }
        }
        if cnt > end {
            return false;
        }
    }
    return true;
}
```

#definition[
  Замыкание $[G]$ $n$-вершинного графа $G$ получается из графа $G$
  добавлением рёбер ${ u \, v }$ для всех пар вершин $u$ и $v$, для
  которых выполняется условие $d (u) + d (v) gt.eq n$.
]

Можно заметить, что алгоритм построения такого замыкания имеет сложность
$O (n^4)$. Немного изменённая версия этого алгоритма используется при
построении гамильтонова цикла на основе нижеследующих теорем.

#theorem([Бонди-Хватал])[
  Граф $G$ является гамильтоновым тогда и только тогда, когда его замыкание
  $[G]$ является гамильтоновым.
] <thm:bondy-chvatal-1>
#theorem([Бонди-Хватал])[
  Если замыкание $[G]$ графа $G$ является полным графом, то граф $G$ ---
  гамильтонов.
] <thm:bondy-chvatal-2>

```
fn get_closure_traced(&self, trace_steps: bool) -> Graph {
    let mut step = if trace_steps { 2 } else { 1 };

    let mut closure = self.clone();
    for _ in 0..(closure.size * closure.size) {
        let mut changed = false;
        for row in 0..closure.size {
            for col in 0..closure.size {
                if row == col || closure.matrix[row][col] != 0 {
                    continue;
                }
                let sum = closure.degree(row) + closure.degree(col);
                if sum >= closure.size {
                    closure.matrix[row][col] = step;
                    if trace_steps {
                        step += 1;
                    }
                    changed = true;
                }
            }
        }
        if !changed {
            break;
        }
    }
    return closure;
}
```

== Алгоритм нахождения гамильтонова цикла на основе условия Бонди-Хватала
<алгоритм-нахождения-гамильтонова-цикла-на-основе-условия-бондихватала>
В том случае, если некоторый граф $G = (V \, alpha)$ отвечает теореме
thm:bondy-chvatal-2, то к нему можно применить алгоритм нахождения
гамильтонова цикла со сложностью $O (n^3)$.

Пусть $A = (a_(i j))$ --- матрица смежности графа $G$. Построим
матрицу смежности замыкания $C_k (G)$ по следующему алгоритму:

+ Установить $(forall i) med D_i = sum a_(i j)$. Установить $M = 2$.

+ Находится некоторая пара $(i \, j)$, где
  $i eq.not j \, a_(i j) = 0 and D_i + D_j gt.eq k$. Если такая пара не
  может быть найдена, то остановить алгоритм.

+ Заменить $a_(i j)$ и $a_(j i)$ на число $M$. Заменить $D_i$ на
  $D_i + 1$ и $D_j$ на $D_j + 1$. Заменить $M$ на $M + 1$. Перейти на
  шаг 2.

Обозначим множество вершин графа как $V (G)$, а множество рёбер как
$E (G)$.

При завершении алгоритма получаем матрицу смежности $A = (a_(i j))$, в
которой $a_(i j) = 1 arrow.l.r.double i j in E (G)$ и
$a_(i j) = 0 arrow.l.r.double i j in.not E (C_k (G))$. Далее, возьмём
некоторый гамильтонов цикл $C : med u_1 u_2 dots.h u_n u_1$ в замыкании
$C_k (G)$. Так как по условию теоремы, это замыкание полное, то можно
взять любой набор вершин графа. Обозначим $m$ равным максимальному
значению $a_(i j)$ среди всех рёбер цикла $C$. Если $m > 1$, то ребро с
таким значением уникально. Если $m = 1$, то цикл $C$ является искомым
гамильтоновым циклом в графе $G$. Пусть ребро у которого $a_(i j) = m$
--- это $u_1 u_n$. Тогда построить новый цикл $C'$ такой, что
максимальное значение $a_(i j)$ среди его рёбер меньше, чем $m$. Найдём
вершину $u_s$ такую, что $0 < a_(u_1 u_(s + 1)) < m$ и
$0 < a_(u_n u_s) < m$ за $O (n)$ шагов. Тогда, цикл $C'$:
$ u_1 u_(s + 1) u_(s + 2) dots.h u_n u_s u_(s - 1) dots.h u_1 $

Данную процедуру необходимо повторять до тех пор, пока гамильтонов цикл
не будет найден. Так как $(forall i \, j) med a_(i j) lt.eq C_n^2$,
первоначальный цикл $C$ в замыкании $C_n (G)$ будет преобразован в
гамильтонов цикл в графе $G$ не более, чем за $O (n^3)$ шагов.

= Достаточные условия, основанные на жёсткости
<достаточные-условия-основанные-на-жёсткости>
Впервые понятие жёсткости было введено Вацлавом Хваталом в 1973 году.
Впоследствии на основе данного понятия было доказано большое количество
новых достаточных условий гамильтоновости графов. Например, в 2006 году
было проведено обширное исследование таких условий с результатами от
разных авторов bauer2006toughness. Далее приведены две теоремы,
основанные на понятии жёсткости, а также необходимые для этих теорем
определения.

Для вычисления количества компонент графа можно использовать алгоритм
поиска в глубину со сложностью $O (n + m)$.

```
fn dfs(&self, vertex: &usize, visited: &mut Vec<usize>) {
    visited[*vertex] = 1;
    for i in 0..self.size {
        if visited[i] == 0 && self.matrix[*vertex][i] != 0 {
            self.dfs(&i, visited);
        }
    }
}

fn count_components_partial(&self, included_vertices: &Vec<i32>) -> usize {
    let mut visited = vec![0; self.size];
    for i in 0..included_vertices.len() {
        if included_vertices[i] == 0 {
            visited[i] = 1;
        }
    }
    let mut count = 0;
    while visited.iter().sum::<usize>() != visited.len() {
        let mut next = 0;
        for i in 0..self.size {
            if visited[i] == 0 {
                next = i;
                break;
            }
        }
        self.dfs(&next, &mut visited);
        count += 1;
    }
    return count;
}
```

#definition[
  Граф является $t$-жёстким, если
  $(forall med S subset.eq V (G) med : med omega (G - S) > 1) med lr(|S|) gt.eq t dot.op omega (G - S)$.
]
```
fn check_toughness(&self, t: f64) -> bool {
    for cutset in self.cutsets() {
        let components_count = cutset.graph.count_components_partial(&cutset.vertices) as f64;
        let cut_cardinality = (self.size - cutset.cardinality) as f64;
        if components_count > 1.0 && cut_cardinality < t * components_count {
            return false;
        }
    }
    return true;
}
```

Можно заметить, что проверка графа на $t$-жёсткость имеет сложность
$O (2^n)$, что делает данные условия крайне неэффективными для проверки.

#definition[
  Жёсткость $tau (G)$ --- максимальное значение $t$, для которого граф
  $G$ является $t$-жёстким.
]

Так как функция жёсткости $tau$ является вещественной, монотонной и
скачковой, значение жёсткости графа можно найти с помощью алгоритма
бинарного поиска, имеющего сложность $O (log (n))$. Вкупе с проверкой
графа на $t$-жёсткость, сложность нахождения жёсткости имеет сложность
$O (2^n dot.op log (n))$

Обозначим $delta (G)$ --- минимальную степень в графе $G$ и
$omega (G)$ --- количество компонент связности в графе $G$.

#definition[
  Множество вершин называется независимым, если никакие две из них не
  смежны harary_1973. Обозначим мощность максимального множества
  независимых вершин графа $G$ как $alpha (G)$.
]

#theorem([Бигалке-Юнг])[
  Если для 1-жёсткого графа $G$ с числом вершин $n gt.eq 3$ выполняется
  неравенство $delta gt.eq max { n \/ 3 \, alpha - 1 }$, то граф $G$ ---
  гамильтонов.
] <thm:bigalke>
#theorem([Бауэр])[
  Если для $t$-жёсткого графа $G$ с числом вершин
  $n gt.eq 3$ выполняется неравенство $delta gt.eq n \/ (t + 1) - 1$, то
  граф $G$ --- гамильтонов.
] <thm:bauer>

= Достаточные условия, основанные на запрещённых подграфах
<достаточные-условия-основанные-на-запрещённых-подграфах>
Условия, представленные в данном разделе используют широко
распространённую концепцию запрещённых подграфов. Произвольный граф $G$
называют свободным от подграфа $H$ в том случае, если ни один из
подграфов графа $G$ не является изоморфным графу $H$. В общем случае
проверка на запрещённость подграфа является NP-полной задачей, так как
необходимо перебрать все подграфы и проверить их на изоморфность
некоторому другому подграфу.

Но есть возможность улучшения сложности проверок для графов,
рассмотренных в данной работе с помощью алгоритма представленного в
статье hopcroft1974linear, в которой описан алгоритм проверки
изоморфизмов на планарных графах. Графы, рассмотренные в данной работе
(рис. fig:forbidden), очевидно планарные. В случае, если планарность
графов не очевидна, существует линейный алгоритм проверки на
планарность, представленный в работе hopcroft1974efficient.

Также перед рассмотрением теорем необходимо ввести определение вершинной
$k$-связности.

#definition[
  Произвольный граф $G$ является вершинно $k$-связным (или просто
  $k$-связным), если он имеет больше чем $k$ вершин и после удаления
  менее чем $k$ любых вершин граф остаётся связным. 2-связный граф также
  можно назвать двусвязным, а 3-связный --- трисвязным.
]

Рассмотрим сами теоремы с достаточными условиями.

#theorem([Duffus-Gould-Jacobson])[
  Если граф $G$ является двусвязным и свободным от подграфов
  \$\\set{K\_{1, 3}, N}\$, то он также является гамильтоновым.
] <thm:duffus-gould-jacobson>

#theorem([Broersma-Veldman])[
  Если граф $G$ является двусвязным и свободным от подграфов
  \$\\set{K\_{1, 3}, P\_6}\$, то он также является гамильтоновым.
] <thm:broersma-veldman>

#theorem([Gould-Jacobson])[
  Если граф $G$ является двусвязным и свободным от подграфов
  \$\\set{K\_{1, 3}, Z\_2}\$, то он также является гамильтоновым.
] <thm:gould-jacobson>

#theorem([Bedrossian])[
  Если граф $G$ является двусвязным и свободным от подграфов
  \$\\set{K\_{1, 3}, W}\$, то он также является гамильтоновым.
] <thm:bedrossian>

Следующая теорема формулируется похожим образом на теорему
thm:duffus-gould-jacobson, но при этом в результате получается более
сильное условие гамильтоновой связности.

#definition[
  Произвольный граф $G$ называется гамильтоново-связным в том случае,
  если между любой парой его вершин существует гамильтонов путь.
]

#theorem([Shepherd])[
  Если граф $G$ является трисвязным и свободным от подграфов
  \$\\set{K\_{1, 3}, N}\$, то он также является гамильтоново-связным.
] <thm:shepherd>

#figure(
  image("images/forbidden.jpg"),
  caption: "Рассмотренные запрещённые подграфы",
) <fig:forbidden>

= Практическая реализация
<практическая-реализация>
Для произведения вычислительного эксперимента необходимо выполнить
программную реализацию указанных ранее достаточных условий. Таким
образом можно сравнить результаты, получаемые для одинаковых видов
графов при применении разных условий.

Имеет смысл проверять условия только для неизоморфных графов, что
позволит значительно уменьшить количество необходимых проверок. Так как
задача перечисления всех неизоморфных графов не исследуется в рамках
этой работы, была использована программ `geng` из пакета `nauty`
mckay2014practical для генерации графов в формате `graph6` graph6.

Для выполнения непосредственных вычислений была написана программа на
языке программирования Rust, исходный код которой указан в Приложениях
// @app:rust1 -- @app:rust14.

Кроме программой реализации самих условий, была адаптирована программа
#emph[geng] для выполнения перебора графов программно, а не с помощью
чтения из стандартного ввода. С помощью библиотеки #emph[tokio] было
выполнено распределение вычислений по всем ядрам процессора. Так как
параметры #emph[res/mod] утилиты #emph[geng] не позволяют разделить
перебор всех неизоморфных графов на равные части, такой подход позволил
#emph[равномерно] распределить вычисления.

Исходный код упомянутой адаптации утилиты #emph[geng] указан в
Приложении app:geng_iter.

Так как с увеличением количества рассматриваемых вершин, количество
графов увеличивается экспоненциально, одной из основных практических
задач при разработке практической реализации является наиболее
эффективное распределение вычислений на доступные вычислительные
мощности.

При разработке программы была реализована возможность создания пула
компьютеров для "добровольных" распределённых вычислений. Это
означает, что на каждый из компьютеров переносится программа-клиент,
которая может производить необходимые вычисления, наиболее эффективно
распределяя нагрузку на данном компьютере.

Протокол работы такой системы можно описать следующим образом:

+ Сервер-координатор запускается на компьютере, доступном всем
  разрешённым "добровольцам";

+ Клиенты запускаются на всех компьютерах, которые будут участвовать в
  непосредственных вычислениях и регистрируют свою готовность на
  сервере;

+ Клиент запрашивает новую задачу у сервера тогда, когда у клиента
  появится возможность выполнять вычисления;

+ При запросе задачи, сервер генерирует пакет со списком графов для
  обработки и отправляет клиенту;

+ Клиент обрабатывает задачу и при окончании отправляет результат
  серверу;

+ Сервер принимает результаты и записывает их в хранилище.

Общение между клиентами и сервером происходит по протоколу HTTP(S). На
клиенты графы отправляются в виде пакетов из одинакового количества
графов (кроме самого последнего пакета, так как может остаться меньшее
количество графов, чем передаётся в пакете) в формате graph6.

Пример возможных параметров командной строки, которые можно задавать при
запуске клиента, либо сервера, можно увидеть на рисунке fig:cli.

#figure(
  image("images/cli.png", width: 90.0%),
  caption: "Командный интерфейс программы graph-checker",
) <fig:cli>

Временем, которое уходит на генерацию большого списка графов и его
дальнейшей передачи по сети можно пренебречь, так как оно значительно
меньше, чем время, уходящее на обработку одного пакета. В связи с этим,
так же можно пренебречь избыточностью используемого протокола HTTP.
Взамен этой избыточности, можно получить удобные и проверенные
библиотеки для разработки такого рода программы.

Приложение с такой архитектурой можно использовать несколькими способами

- Все клиенты и сервер находятся в закрытом контуре, являются
  выделенными под конкретную задачу и работают непрерывно пока не
  завершится выполнение всей задачи (не обработаются все графы с
  указанным количеством вершин);

- Сервер запущен публично и все клиенты действительно
  "добровольцы", которые присоединяются к пулу тогда, когда
  компьютер свободен от других задач.

Таким образом, при использовании разработанной программы, есть
возможность простого распределения задачи проверки достаточных условий
гамильтоновости для графов с большим количеством вершин, чем было бы
возможно при распределении вручную. Также это открывает возможность для
создания публичных серверов для вычислений, к которым могут
присоединяться другие добровольцы.

Визуализации графов подготовлены с помощью программы на языке
программирования Python с использованием библиотеки NetworkX.
Визуализации выводятся в формате PGF/TikZ (Приложение @app:drawer).

Результаты вычислительного эксперимента были записаны в БД под
управлением СУБД Sqlite. Каждый граф идентифицируется в БД с помощью
своего представления в формате #emph[graph6] graph6.

= Вычислительный эксперимент
<вычислительный-эксперимент>
== Условия, основанные на жёсткости
<условия-основанные-на-жёсткости>
По результатам вычислений, указанных в таблице tbl:stats, можно
заметить, что Теоремы thm:bigalke и thm:bauer по эффективности
сравнимы с теоремой thm:posa, поэтому проведём более подробное
сравнение графов, отвечающих данным условиям.

#figure(
  table(
    columns: 8,
    align: (center, center, center, center, center, center, center, center),
    table.header(
      [$n$],
      [Всего],
      [Дирак],
      [Оре],
      [Поша],
      [Бонди-Хватал],
      [Бигалке-Юнг],
      [Бауэр],
    ),
    table.hline(),
    [3], [4], [1], [1], [1], [1], [1], [1],
    [4], [11], [3], [3], [3], [3], [3], [3],
    [5], [34], [3], [5], [6], [7], [8], [10],
    [6], [156], [19], [21], [31], [45], [48], [19],
    [7], [1044], [29], [68], [190], [352], [145], [145],
    [8], [12346], [424], [503], [2484], [5540], [2553], [2047],
    [9], [274668], [1165], [4942], [53492], [157016], [83481], [59395],
    [10], [12005168], [108376], [128361], [2683649], [8298805], [1249871], [1245462],
  ),
  caption: [Количество графов, отвечающих рассмотренным теоремам],
  kind: table,
) <tbl:stats>

Для этого была написана программа на языке программирования Python,
считывающая вывод программы подсчёта количества графов (которая также
выводит сами графы, отвечающие заданным условиям). Данная программа
приведена в Приложении app:python.

С помощью этой программы можно проверить пересечения и разности разных
комбинаций множеств графов Поша, графов Бауэра и графов Бигалке-Юнга
(рис. fig:checker-py).

#figure(
  image("images/python_runner.png", width: 70.0%),
  placement: auto,
  caption: [
    Пример вывода программы checker.py
  ],
)
<fig:checker-py>

Выполнив данную программу для графов размером до 8 вершин удалось
установить несколько фактов об отношениях данных условий
гамильтоновости:

- Для графов размеров 3, 4, 5 графы Поша являются подмножеством как
  графов Бауэра, так и графов Бигалке-Юнга. При этом, графы Поша
  дополнительно являются подмножеством графов Бигалке-Юнга, но не
  Бауэра это связанно с тем, что при 6 вершинах графов Бауэра меньше,
  чем графов Поша. В данном случае, наоборот, Графы Бауэра являются
  подмножеством графов Поша;

- Пересечения множеств графов Поша & графов Бауэра совпадают с
  пересечениями графов Поша & графов Бигалке-Юнга вплоть до графов с 8
  вершинами, кроме случая с 6 вершинами;

- Графы Бигалке-Юнга с 7 вершинами совпадают с графами Бауэра с 7
  вершинами.

== Условия, основанные на запрещённых подграфах
<условия-основанные-на-запрещённых-подграфах>
В таблице tbl:forbidden-full указаны значения количества графов,
которые определяются каждой из рассмотренных в разделе с запрещёнными
подграфами теорем.

#figure(
  table(
    columns: 7,
    align: (center, center, left, left, left, center, center),
    table.header(
      [$n$],
      [Бонди-Хватал],
      [Duffus-Gould-Jacobson],
      [Broersma-Veldman],
      [Gould-Jacobson],
      [Bedrossian],
      [Shepherd],
    ),
    table.hline(),
    [4], [3], [], [], [], [3], [1],
    [5], [7], [], [], [], [8], [3],
    [6], [45], [], [], [], [32], [13],
    [7], [352], [], [], [], [122], [60],
    [8], [5540], [], [], [], [554], [359],
    [9], [157016], [], [], [], [2723], [2241],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
    [10], [8298805], [], [], [], [16446], [15889],
  ),
  caption: [Количество определяемых гамильтоновых графов],
  kind: table,
) <tbl:forbidden-full>

Абсолютные значения количества определяемых графов не представляют
особой ценности, так как условие Бонди-Хватала определило значительно
большее количество графов. Более полезными будут данные о разности
множеств графов, определяемых указанными теоремами с графами,
определяемыми эталонной теоремой Бонди-Хватала.

В колонках таблицы tbl:forbidden-diff указан размер множества графов,
определяемый теоремой, соответствующей колонке. Данные вычислялись по
формуле $lr(|T_(B H) - (T_(B H) inter T)|)$, где $T_(B H)$ ---
множество графов, определяемых теоремой Бонди-Хватала, $T$ ---
множество графов, определяемых теоремой, указанной в колонке.

#figure(
  table(
    columns: 6,
    align: (center, left, left, left, center, center),
    table.header(
      [$n$],
      [Duffus-Gould-Jacobson],
      [Broersma-Veldman],
      [Gould-Jacobson],
      [Bedrossian],
      [Shepherd],
    ),
    table.hline(),
    [4], [], [], [], [0], [0],
    [5], [], [], [], [1], [0],
    [6], [], [], [], [2], [0],
    [7], [], [], [], [8], [0],
    [8], [], [], [], [11], [1],
    [9], [], [], [], [34], [14],
    [10], [], [], [], [46], [67],
  ),
  caption: [Разность условий с условием Бонди-Хватала],
  kind: table,
) <tbl:forbidden-diff>

Также можно заметить, что первые четыре теоремы формулируются
практически одинаково, за исключением множества запрещённых подграфов.
То есть, можно объединить данные условия в одно и узнать сколько графов
они способны определить вместе. В таблицу tbl:forbidden-union занесены
данные о количестве определённых графов объединением теорем
thm:duffus-gould-jacobson, thm:broersma-veldman, thm:gould-jacobson и
thm:bedrossian.

#figure(
  table(
    columns: 2,
    align: (center, center),
    table.header(
      [$n$],
      [Bedrossian, Broersma, Duffus, Gould, Jacobson,
        Veldman],
    ),
    table.hline(),
    [4], [0],
    [5], [1],
    [6], [2],
    [7], [11],
    [8], [42],
    [9], [204],
    [10], [885],
  ),
  caption: [Объединение теорем],
  kind: table,
) <tbl:forbidden-union>

Можно увидеть, что практически все графы из объединённой теоремы
определяются теоремой thm:duffus-gould-jacobson.

#conclusion

Наиболее эффективным условием (по проценту определяемых графов), всё ещё
остаётся условие Бонди-Хватала, которое позволяет установить
гамильтоновость примерно 90% графов.

Хотя теоремы Бауэра и Бигалке-Юнга на небольшом количестве вершин
сравнимы с условием Поша, уже на 10 вершинах они значительно уступают
данному условию. При этом, имея вычислительную сложность
$O (2^n dot.op log (n))$, они являются крайне неэффективными способами
установления гамильтоновости графов.

Так как алгоритм определения жёсткости работает за неполиномиальное
время, достаточные условия гамильтоновости графов, основанные на этом
определении, являются лишь небольшим улучшением по сравнению с обычным
перебором различных вариантов построения гамильтонова цикла в графе,
который также является NP-полной задачей.

Теорема Поша, с которой производилось сравнение теорем thm:bigalke и
@thm:bauer является более подходящей для такой задачи, так как способна
определять гамильтоновость более 25% графов, при этом имея значительно
более эффективную сложность $O (n + m)$.

Теоремы, основанные на запрещённых подграфах при этом позволяют
определить ещё меньшее количество графов по сравнению с другими
рассмотренными теоремами. Но при этом они позволяют определять некоторые
из графов, которые не способна определить теорема Бонди-Хватала,
которая является самой эффективной из рассмотренных.

Данные теоремы в основном представляют теоретический интерес, так как
рассматривают совершенно иной способ определения гамильтоновости для
произвольных графов. Хотя они являются достаточно неэффективными в
смысле вычислительной сложности, они всё же имеют полиномиальную
сложность и поэтому в некоторых случаях их можно использовать для
проверки на гамильтоновость тех графов, которые не способна определить
теорема Бонди-Хватала. Например, такие теоремы позволяют распознать
гамильтоновы графы с небольшим количеством рёбер вокруг цикла.

В результате выполнения работы, была реализована программа, позволяющая
эффективно выполнять вычисления достаточных условий гамильтоновости
графов, а также распределять эти вычисления между несколькими
компьютерами. Помимо изученных в этой работе теорем, были реализованы
инструменты для работы с графами на языке Rust, а также внедрена
библиотека geng для более эффективного перебора неизоморфных графов. Эти
инструменты можно использовать для любых других задач, связанных с
графами, а также эффективно распределять эти задачи между множеством
вычислителей.

@app:rust1

@eichten1984supercollider

#bibliography("test.bib")


#show: annexes-start

= Основной модуль программы, файл main.rs <app:rust1>
#source-file("/test.bib")

= Модуль с общими операциями над графами, файл graph.rs <app:rust2> <app:drawer>
#source-file("/install.sh")

// #appendix-start

// #appendix[Основной модуль программы, файл main.rs] <app:rust1>
// #source-file("test.bib")
//
// #appendix[Модуль с общими операциями над графами, файл graph.rs]
// <app:rust2>
//
// #appendix[Достаточные условия, файл theorems/basic.rs]
// <app:rust3>
// #appendix[Достаточные условия на основе запрещённых подграфов, файл theorems/forbidden.rs]
// <app:rust4>
// #appendix[Модуль с достаточными условиями на основе жёсткости, файл theorems/toughness.rs]
// <app:rust5>
// #appendix[Модуль theorems, файл theorems/mod.rs]
// <app:rust6>
// #appendix[Программная связка с библиотекой geng, файл geng.rs]
// <app:rust7>
// #appendix[Модуль вычисления метрик, файл compute.rs]
// <app:rust8>
// #appendix[Модуль клиента, файл client.rs]
// <app:rust9>
// #appendix[Модуль сервера, файл server.rs]
// <app:rust10>
// #appendix[Модуль с глобальным контекстом, файл context.rs]
// <app:rust11>
// #appendix[Модуль с привязками к таблицам БД, файл models.rs]
// <app:rust12>
// #appendix[Cерверные обработчики запросов, файл routes.rs]
// <app:rust13>
// #appendix[Скрипт сборки программы, файл build.rs] <app:rust14>
//
// #appendix[Абстракция итератора над программой geng, файл geng-iter.c]
// <app:geng_iter>
// #appendix[Исходный код программы сравнения множеств графов на языке Python]
// <app:python>
// #appendix[Исходный код программы визуализации графов на языке Python] <app:drawer>
// #source-file("test.bib")
